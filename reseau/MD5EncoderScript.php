<?php 

/*
generate a random 32 bits integer
*/
function generate32BitInteger(){
	return rand(0,4294967295);
}

/*
add x 0 to the left of binary number (little endian) as stringuntil the size reach $base
*/
function base($binary_str, $base){
	$result = $binary_str;
	if(strlen($binary_str) < $base ){
		$padding = str_repeat('0',$base - strlen($binary_str));
		$result = $padding.$binary_str;
	}
	return $result;
}

/*
convert 32 bit integer to hexadecimal string
*/
function decimalToHex32($value){
	$value_temp = str_split(base(decbin($value),32),4);
	$result = '';
	foreach($value_temp as $hexChar){
		$char = bindec($hexChar);
		if($char < 10){
			$result .= $char;
		}else{
			switch ($char) {
				case 10:
					$result .= 'a';
					break;
				case 11:
					$result .= 'b';
					break;
				case 12:
					$result .= 'c';
					break;
				case 13:
					$result .= 'd';
					break;
				case 14:
					$result .= 'e';
					break;
				case 15:
					$result .= 'f';
					break;
			}
		}
	}

	return $result;
}

/*
generate 4 random default value for A B C and D (default value in comm)
*/
function generateMD5Key(){
	//generate 32bit key word for MD5 algorithm
	$a0 = generate32BitInteger(); //1732584193
	$b0 = generate32BitInteger(); //4023233417
	$c0 = generate32BitInteger(); //2562383102
	$d0 = generate32BitInteger(); //271733878
	//format the key for better transport as a string
	$key = decimalToHex32($a0).' '.decimalToHex32($b0).' '.decimalToHex32($c0).' '.decimalToHex32($d0);
	return $key;
}

/*
function for MD5 algorithm
*/
function leftrotate($value, $rotate){
	return ($value << $rotate) | ($value >> (32-$rotate));
}


/*
$message : string, the message to encode 
$key : string generated by generateMD5Key()

*/
function MD5Encode($message, $key){
	$key = explode(" ", $key);
	$a0 = hexdec($key[0]); 
	$b0 = hexdec($key[1]); 
	$c0 = hexdec($key[2]); 
	$d0 = hexdec($key[3]);

	// Use binary integer part of the sines of integers (Radians) as constants:
	$K = [];			
	for($i=0;$i<64;$i++){
		$K[$i] = floor((2**32) * abs(sin($i+1)));
	}

	//specifies the per-round shift amounts (leftrotate($F, $s[g]))
	$s = [7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,
	  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,
	  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,
	  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21];

	//if message size is over 2^64 can't encode the message
	if(strlen($message) >= 2305843009213693952){
		throw new Exception('this string is too big');
	}

	//converting the message to an integer array
	$message_bin = unpack('C*', $message);
	$data_str = '';
	foreach($message_bin as $value){
		//transform integer to a base8 binary string
		$binchar = base(decbin($value), 8);
		$data_str .= $binchar;
	}

	//binary message size in a base64 integer
	$data_len = strlen($data_str);
	$data_len = base(decbin($data_len), 64);

	//append 1
	$data_str = $data_str.'1';
	//append 0 to the rigth until strlen($data_str)%512 == 448
	$padding = '0';
	while(strlen($data_str)%512 != 448){
		$data_str = $data_str.$padding;
	}

	//append base64 message size
	$data_str = $data_str.$data_len;


	$data_packet = str_split($data_str, 512);
	//MD5 algorithm
	foreach($data_packet as $message_blocks){
		//split the block into 16 32bit words
		$M = str_split($message_blocks, 32);	//string[]
		$A = $a0;								//integer
		$B = $b0;								//integer
		$C = $c0;								//integer
		$D = $d0;								//integer

		for($i = 0 ; $i < 64 ; $i++){			//$i: integer
			//transition variables
			$F = $g = 0;

			//all operations are binary
			//$i ∈ [0;15]
			if($i <=15){
				$F = ($B & $C) | ((~$B) & $D); // F = (B and C) or ((not B) and D)
				$g = $i;
			//$i ∈ [16;31]
			}else if($i <= 31){
				$F = ($D & $B) | ((~$D) & $C);
				$g = (5*$i +1) % 16;
			//$i ∈ [32;47]
			}else if($i <= 47){
				$F = $B ^ $C ^ $D;
				$g = (3*$i +5) % 16;
			//$i ∈ [48;63]
			}else{
				$F = $C ^ ($B | (~$D));
				$g = (7*$i) % 16;
			}

			$F = $F + $A + $K[$i] + bindec($M[$g])%(2**32);
			$A = $D;
			$D = $C;
			$C = $B;
			$B = $B + leftrotate($F, $s[$i])%(2**32);
		}

		$a0 += $A;
		$b0 += $B;
		$c0 += $C;
		$d0 += $D;
	}

	$MD5EncodedMessage =  decimalToHex32($a0%(2**32)).decimalToHex32($b0%(2**32)).decimalToHex32($c0%(2**32)).decimalToHex32($d0%(2**32));
	return $MD5EncodedMessage;
}


?>